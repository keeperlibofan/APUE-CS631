### 进程关系

每一个进程都会有他的父进程。

初始的内核级进程通常就是自己的父进程。

linux系统的getty，getty对终端调用open函数，以读和写的方式将终端打开。
当用户键入了用户名后，getty的工作就完成了。然后就会以类似以下方式调用login程序：
```cpp
execle("/bin/login", "login", "-p", username, (char *)0, envp);
```

当login开始被调用的时候，这些进程的状态：
进程id为1的init fork出一个init进程，然后exec子进程getty(getty打开终端设备(文件描述符0，1，2)读用户名，初始环境集)，然后getty进程exec成login
进程。

login处理多项工作，登录操作后如果用户键入的口令无效，那么login以exit(1),来退出登录过程表示登录失败。

登录成功后，会调用
```cpp
execl("/bin/sh", "-sh", (char *)0); // 第一个-号表示被当做登录shell调用。
```

login程序在较早的时候会调用setuid，setgid来改变当前用户。
当变成shell后，shell终止了，init程序会接收到一个通知（SIGCHLD）信号。登录shell会读取其启动文件，启动文件
一般会更改某些环境变量或者添加某些环境变量。执行完启动文件后，才会出现shell的提示符号，shell等待用户键入命令。

#### 网络登录

BSD有一个叫做inetd的进程(因特网超级服务器)，等待大多数的网络连接。inetd等待TCP/IP连接请求到达到主机，而当一个请求连接到达的时候，它也是fork一个子进程然后exec适当的程序。
inetd子进程exec telnetd后，然后telnetd进程fork出两个进程，一个用户处理通过网络的连接通信，另外一个子进程则执行login程序。父进程和子进程通过伪终端连接。在调用exec之前，子进程让
文件描述符0，1，2与伪终端连接。

#### 进程组
进程组是多个进程的集合，同一个进程组中的各个进程接受来自终端的各种信号，每一个进程组有一个唯一的进程组ID。函数getpgrp返回调用进程的进程组id.
每一个进程组有一个组长进程，而且进程组长的id就等于进程组的id。

一个进程只能为他自己，或者他的子进程修改pgid（通过setpgid），如果子进程调用exec后，就不再改变该子进程的pgid。

信号可以专门发给一个指定的进程也可以发给某个特定的进程组，同时waitpid也可以指定接受一个进程组某个终止进程的id。

#### 会话
会话是一个进程组或者多个进程组的集合。通常是由shell的管道将几个进程编成一个组。

setsid创建一个新的会话
+ 调用此函数的进程会变成会话首进程，改进程是新会话的唯一进程。
+ 该进程成为新进程的组长进程。
+ 该进程没有控制终端(暂时不知道什么是控制终端)。如果有的话也会被切断

调用进程不能是一个进程组的组长，这样会报错，所以一般用进程的fork子进程，因为这样在任何情况下的子进程的进程id不会是组长进程。

#### 控制终端
+ 一个会话会有一个控制终端，这通常是终端设备(本地)，伪终端设备(在网络的情况下)。
+ 与终端连接的会话首进程被称之为控制进程。
+ 一个会话中的几个进程组可以被分为一个前台进程组，和多个后台进程组。
+ 键入终端键，中断的信号会发送到前台进程组的所有进程。
+ 挂断信号只会发送给会话首进程。

/dev/tty 是控制终端的同义语。

#### 三个函数

由内核来通知哪一个进程组是前台进程

tcgetpgrp返回前台进程组的id。
tcsetpgrp将前台进程组id设置为pgrpid参数，这个参数应当是当前会话中的一个进程组的id。fd参数必须是引用该会话的控制终端。

tcgetsid识别出控制终端的会话首进程的会话id
#### 作业控制

+ 支持作业控制的shell
+ 内核必须提供对某些作业控制的信号支持

一个作业只是几个进程的集合，通常是一个进程管道。例如：
vi main.c
在前台启动了一个作业

影响前台作业的特殊字符---挂起键(Ctrl+Z),键入此键将使终端驱动程序将信号SIGTSTP发送到
前台进程组的所有进程。
+ SIGINT
+ SIGQUIT
+ SIGTSTP
+ SIGTTIN: 当后台作业也在读取控制终端的时候，驱动程序会检测这种情况，并且发送一个SIGTTIN信号以停止后台作业，然后发出这种情况的通知，这个时候调用

`$fg %1` // 1代表一号作业  
就可以转为前台运行。

当终端驱动程序将SIGTTIN发送给后台作业后，shell会检测到其状态的改变，因为子进程是shell的子进程，shell可以通过wait
和waitpid来捕捉信号，然后shell通知我们进程已经被停止。然后我们用fg调出这个作业前台运行(tcsetpgrp)
并将`继续信号`(SIGCONT)传给该进程组。

禁止后台作业输出到控制终端。

$ stty tostop // 禁止后台作业输出到控制终端

这个时候，如果
`cat temp.foo &`
会返回子进程停止（SIGTTOU）信号。这是因为cat被阻塞了。

#### shell执行程序

 不知道作业控制的shell不会将后台作业放入自己的进程组，也没有从后台作业中取走终端。
 
 管道中的最后一个进程是shell的子进程，管道中的第一个进程是最后一个进程的子进程。可以看出
 shell 会fork出一个副本，然后该副本再为管道中的每一个命令各fork一个进程。(很重要)
 
 如果shell不支持作业控制，当后台程序需要从标准输入读取的时候，shell自动将后台程序的标准输入定向到
 /dev/null中，这个时候读取/dev/null会产生一个`文件结束`标志。
 
 crypt 会打开/dev/tty，然后更改终端的特性(禁止回显)，然后会重置终端的特性。
 
 在支持作业控制的shell，执行ps命令的时候，ps自己成立一个进程组，并且成为组长，而且还是前台进程组，这就代表着它有控制终端。
 而执行ps时shell是后台命令组。
 
 
 #### 孤儿进程组
 
 挂断信号(SIGHUG)，就是把前台进程挂起，这需要进程建立挂断信号的处理机制。
当子进程的父进程gg后，子进程成为孤儿进程组的一个成员，此时此刻，组长进程并不是他，而是他已经gg掉的爸爸，

POSIX对孤儿进程组的定义就是：该进程组的每个成员的父进程要么是该组的成员，要么在其它会话中。

#### 信号 
型号是软件中断。

信号是异步事件的典型实例，产生信号的事件对于进程而言是完全随机出现的。

SIGKILL信号和SIGSTOP信号都是内核主动来处理的，强制性的实施，对用户而言，是不能捕捉到的。

信号阻塞和信号未决
+ 信号的“未决”是一种状态，指的是从信号的产生到信号被处理前的这一段时间；
+ 信号的“阻塞”是一个开关动作，指的是阻止信号被处理，但不是阻止信 号产生。

当信号发生的时候，内核通常在进程表中以某种形式设置一个标志。

+ SIGTTOU: 当后台进程想要写其控制终端
+ SIGTTIN: 当后台进程想要读取控制终端

被阻塞的系统调用
系统调用被分为两类：
+ 低速系统调用
+ 其他系统调用

被中断的系统调用必须显示的处理其出错返回。
```cpp
again:
    if ((n = read(fd, buf, BUFFSIZE)) < 0) {
        if (errno == EINTR) { // 中断的系统调用
            goto again;
        }
        // 处理其他的错误
    }
```

自动重启动，BSD容许基于某个信号禁止其功能。在写到低速的系统调用的时候，我们还要考虑
到当系统调用被阻塞时的处理方式。

#### 信号集合
+ sigemptyset：初始化参数set指向的信号集合

#### 不可靠的信号机制

信号可能会被丢失

#### sigaction函数

mac的sigaction可以传两个sigaction结构体，sa_sigaction(`void (*__sa_sigaction)(int, struct __siginfo *, void *)`)字段是一个替代的信号处理程序(),当sigaction字段设置为SA_SIGINFO的标志的时候，使用该处理程序。
```cpp
struct sigaction sigaction1 = {
            sig_cld,
            sigset1,
            SA_SIGINFO, // 代表这个结构中的第一个sig_cld是一个sa_sigaction
}; 
```



几种搭配
+ 处理函数和信号屏蔽字搭配
+ sa_flag中自动重启有关
+ signo是SIGCHLD，SA_NOCLDSTOP flag被设置，子进程停止(作业控制)不产生此信号。从停止到运行时也不
产生信号
+  

#### SIGCLD语义
如果进程明确的将信号的配置设置为SIG_IGN，则调用进程的子进程将不产生僵尸进程。

如果调用了一个wait函数，那么他将会阻塞直到`所有`的子进程都终止，然后wait函数返回-1
然后把errno设置为ECHILD。

在信号处理程序的开始处调用signal，内核检测是否有需要wait的子进程，因为我们正在处理第一个SIGCHILD信号，所以
确实有这样的子进程）所以再一次产生对该处理程序的调用。所以应当调用wait收到子进程的终止状态后再调用signal函数。
此时仅仅当其他的子进程也都终止的时候，内核才回产生此种信号。

```cpp
int
main () {
    -----
    -----
    signal()
    fork() {
        exit()
    }
    wait() // 先调用exit函数
}

```

#### sigprocmask函数